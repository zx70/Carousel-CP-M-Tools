.TL
A TUTORIAL INTRODUCTION
to the
SOFTWARE TOOLS TEXT EDITOR
.TE
.oh *Tutorial Section**ed Tutorial*
.eh *ed Tutorial**Tutorial Section*
.sp 2
.ce 10
B. W. Kernighan
Bell Laboratories
.sp
and
.sp
M. J. Gralia
Applied Physics Laboratory
Johns Hopkins University
.ce 0
.sp 2
.H2
INTRODUCTION
.PP
.ul
ed
is a "text editor", that is, an interactive program
for creating and modifying "text", using directions
provided by a user at a terminal.  The text is often
a document like this one, or a program or perhaps
data for a program.
.PP
This introduction is meant to simplify learning
.ul
ed.
The
recommended way to learn
.ul
ed
is to read this document,
simultaneously using
.ul
ed
to follow the examples,
then to read the description in section I of the Software Tools manual, all the
while experimenting with
.I ed.
(Solicitation of advice from
experienced users is also useful.)
.PP
Do the exercises!  They cover material not completely
discussed in the actual text.  An appendix summarizes the commands.
.H2
DISCLAIMER
.PP
This is an introduction and a tutorial.
For this reason, no attempt is made to cover more than
a part of the facilities that
.ul
ed
offers (although
this fraction includes the most useful and
frequently used parts).  Also, there is not enough
space to explain basic Software Tools procedures.
We will assume
that you know how to log on and access the Software Tools, and that
you have at least a vague understanding of what a file is.
.PP
You must also know what character to type as the
end-of-line on your particular terminal.  It
is almost always a "return".
Throughout, we will refer to
this character, whatever it is, as "newline".
.H2
CASES
.PP
And about case:  it is traditional to use both upper and
lower case characters when using the Software Tools, but
it is not required.  In describing
.ul
ed,
we will follow that
convention, but
.ul
ed
will work with either.
.PP
But a caution:
.ul
ed
differentiates cases.  If your files
contain both and your terminal is in upper case, you can
get into a "deadly embrace" situation in which you can see a
character but can't delete it.  The solution is simple -
always use both upper and lower case with Software Tools.
.H2
GETTING STARTED
.PP
We'll assume that you have logged in.
The easiest way to get
.ul
ed
is to type
.DS
ed      (followed by a newline)
.DE
.ul
ed
will indicate its readiness to accept commands by
prompting you with some character, often
a colon (:).
When you see this prompt,
you are now ready to go -
.ul
ed
is waiting for you to tell it what to do.
.H2
CREATING TEXT - the Append command "a"
.PP
As our first problem, suppose we want to create some text
starting from scratch.  Perhaps we are typing the very first
draft of a paper; clearly it will have to start somewhere,
and undergo modifications later.  This section will show how
to get some text in, just to get started.  Later
we'll talk about how to change it.
.PP
When
.ul
ed
is first started, it is rather like working with a blank piece
of paper - there is no text or information present.  This must be
supplied by the person using
.ul
ed;
it is usually done by typing in the text, or by reading
it into
.ul
ed
from a file.  We will start by typing in some text, and
return shortly to how to read files.
.PP
First a bit of terminology.  In
.I ed
jargon, the text being worked on is said to be
"kept in a buffer."  Think of the buffer as a
work space, if you like, or simply as the
information that you are going to be editing.
In effect the buffer is like the piece of paper
on which we will write things, then change
some of them, and finally file the whole
thing away for another day.
.PP
The user tells
.ul
ed
what to do to his text by typing instructions
called "commands".  Most commands consist of a single letter.
Each command is typed on a separate line.  (Sometimes
the command is preceded by information about what
line or lines of text are to be
affected - we will discuss these shortly.)
.PP
The first command is
.bd 1
append,
written as the letter
.DS
a
.DE
all by itself.  It means
.bd 1
"append
(or add) text lines to the buffer,
as I type them in."  Appending is rather like writing fresh
material on a piece of paper.
.PP
So to enter lines of text into the buffer, we
just type an "a" followed by a newline,
followed by the lines of text we want, like this:
.DS
.cc #
#nf
a
Now is the time
for all good men
to come to the aid of their party.
.
#cc .
.DE
The only way to stop appending is to type a
line that contains only a period.  The "."
is used to tell
.ul
ed
that we have finished appending.  (Even
experienced users forget that terminating "."
sometimes.  If
.ul
ed
seems to be ignoring you, type an extra line with
just "." on it.  You may then find you've
added some garbage lines to your text, which you'll
have to take out later.)
.PP
After the append command has been done, the
buffer will contain the three lines
.DS
Now is the time
for all good men
to come to the aid of their party.
.DE
The "a" and "." aren't there, because they are not text.
.PP
To add more text to what we already have,
just issue another "a" command, and continue typing.
(Try it now - it won't always work right until
we explain about line numbers.)
.H2
ERROR MESSAGES - "?"
.PP
If at any time you make an error in the
commands you type to
.ul
ed,
it will tell you by typing
.DS
?
.DE
This is about as cryptic as it can be, but with
practice, you can usually figure out how you
goofed.
.H2
WRITING TEXT OUT AS A FILE - the Write command "w"
.PP
It's likely that we'll want to save our text for
later use.  To write out the contents of the buffer
onto a file, we use the
.bd 1
write
command
.DS
w
.DE
followed by the filename we want to write on.
This will copy the buffer's contents onto the
specified file (destroying any previous information on the
file).  To save the text on a file named "junk", for
example, type
.DS
w junk
.DE
Leave a space between "w" and the file name.
.ul
ed
will respond by printing the number of lines it
wrote out.  In our case,
.ul
ed
would respond with
.DS
3
.DE
Writing a file just makes a copy
of the text - the buffer's contents are not disturbed,
so we can go on adding lines to it.  This is
an important point.
.ul
ed
at all times works on a copy of a file, not the file itself.
No change in the contents of a file takes place until you give
a "w" command.  (Writing out the text onto a file from
time to time as it is being created is a good idea,
since if the system crashes or if you make some
horrible mistake, you will lose all the text in
the buffer, but any text that was written  onto a file
is relatively safe.)
.H2
LEAVING ED - the Quit command "q"
.PP
To terminate a session with
.ul
ed,
save the text you're working on by writing it onto a file
using the "w" command, and then type the command
.DS
q
.DE
which stands for
.bd 1
quit.
At this point your buffer vanishes,
with all its text, which is why you want to write it out
before quitting.
.H2
EXERCISE 1:
.PP
Enter
.ul
ed
and create some text using
.DS
.cc #
#nf
a
...text...
.
#cc .
.DE
Write it out using "w".  Then leave
.ul
ed
with the "q" command, and print the file, to see that
everything worked.  (To print a file, say
.DS
cat filename
.DE
Also try
.DS
crt filename
.DE
Here, you need to enter a newline (to see the next page)
or "q" (to quit displaying the text).
.H2
READING TEXT FROM A FILE - the Edit command "e"
.PP
A common way to get text into the buffer is to
read it from a file in the file system.  This is
what you do to edit text that you saved with the "w"
command in a previous session.  The
.bd 1
edit
command "e" fetches the entire contents of a
file into the buffer.  So if we had saved the three
lines "Now is the time", etc., with a "w"
command in an earlier session, the
.ul
ed
command
.DS
e junk
.DE
would fetch the entire contents of the file "junk"
into the buffer, and respond
.DS
3
.DE
which is the number of lines in "junk".
If
anything was already in the buffer,
it is deleted first.
.PP
If we use the "e" command to read a file into the
buffer, then we need not use a file name after a
subsequent "w" command;
.ul
ed
remembers the last file name used in an "e" command, and
"w" will write on this file.  Thus a common way to
operate is
.DS
ed
e file
[editing session]
w
q
.DE
You can find out at any time what file named
.ul
ed
is remembering by typing the
.bd 1
file
command "f".  In our case, if we typed
.DS
f
.DE
.ul
ed
would reply
.DS
junk
.DE
.H2
READING TEXT FROM A FILE - the Read command "r"
.PP
Sometimes we want to read a file into the
buffer without destroying anything that is already
there.  This is done by the
.bd 1
read
command "r".
The command
.DS
r junk
.DE
will read the file "junk" into the buffer; it adds it
to the buffer (after the current line).  So if we do a
read after an edit:
.DS
e junk
r junk
.DE
the buffer will contain
.bd 1
two
copies
of the text (six lines).
.DS
Now is the time
for all good men
to come to the aid of their party.
Now is the time
for all good men
to come to the aid of their party.
.DE
Like the "w" and "e" commands, "r" prints the
number of newlines read in, after the reading
operation is complete.
.PP
Generally speaking, "r" is much less used than "e".
.H2
EXERCISE 2:
.PP
Experiment with the "e" command - try reading
and printing various files.  You may get an
error "?.", typically because you spelled the file
name wrong.  Try alternately reading and appending
to see that they work similarly.  Verify that
.DS
ed filename
.DE
is exactly equivalent to
.DS
ed
e filename
.DE
What does
.DS
f filename
.DE
do?
.H2
PRINTING THE CONTENTS OF THE BUFFER - the Print command "p"
.PP
To
.bd 1
print
or list the contents of the buffer (or parts of
it) on the terminal, we use the print command
.DS
p
.DE
The way this is done is as follows.  We specify the
lines where we want printing to begin and where
we want it to end, separated by a comma, and
followed by the letter "p".  Thus to print the
first two lines of the buffer, for example, (that is,
lines 1 through 2) we say
.DS
1,2p
(starting line=1, ending line=2)
.DE
.ul
ed
will respond with
.DS
Now is the time
for all good men
.DE
Suppose we want to print
.bd 1
all
the lines in the
buffer.  We could use "1,3p" as above if we knew
there were exactly 3 lines in the buffer.  But in
general, we don't know how many there are so what do we
use for the ending line number?
.ul
ed
provides a shorthand
symbol for "line number of last line in buffer" - the dollar
sign "$".  Use it this way:
.DS
1,$p
.DE
This will print
.bd 1
all
the lines in the buffer
(line 1 to the last line.)
.PP
To print the
.bd 1
last
line of the buffer,
we could use
.DS
$,$p
.DE
but
.ul
ed
lets us abbreviate this to
.DS
$p
.DE
We can print any single line by typing the line
number followed by a "p".  Thus
.DS
1p
.DE
produces the response
.DS
Now is the time
.DE
which is the first line of the buffer.
.PP
In fact,
.ul
ed
lets us abbreviate even further:  we can
print any single line by typing
.bd 1
just
the line number - no need to type the letter "p".
So if we say
.DS
$
.DE
.ul
ed
will print the last line of the buffer for us.
.PP
We can also use "$" in combinations like
.DS
$-1,$p
.DE
which prints the last two lines of the buffer.
This helps when we want to see how far we got
in typing.
.H2
EXERCISE 3:
.PP
As before, create some text using the append
command and experiment with the "p" command.
You will find, for example, that you can't print
line 0 or a line beyond the end of the
buffer, and that attempts to print a buffer in
reverse order by saying
.DS
3,1p
.DE
does not work.
.H2
THE CURRENT LINE - 'Dot' or '.'
.PP
Suppose our buffer still contains the six
lines as above, that we have just typed
.DS
1,3p
.DE
and
.ul
ed
has printed the three lines for us.
Try typing just
.DS
p     (no line numbers).
.DE
This will print
.DS
to come to the aid of their party.
.DE
which is the third line of the buffer.  In fact
it is the last (most recent) line that we have done
anything with.  (We just printed it!)  We can
repeat this "p" command without line numbers,
and it will continue to print line 3.
.PP
The reason is that
.ul
ed
maintains a record of
the last line that we did anything to (in this case,
line 3, which we just printed) so that it can be
used instead of an explicit line number.  This
most recent line is referred to by the shorthand
symbol
.DS
.cc +
+ti +6
.     (pronounced "dot").
+cc .
.DE
Dot is a line number in the same way that "$"
is; it means exactly "the current line", or
loosely, "the line we most recently did something to." 
We can use it in several ways - one possibility
is to say
.DS
.cc #
.,$p
#cc .
.DE
This will print all the lines from (including) the
current line to the end of the buffer.  In our case
these are lines 3 through 6.
.PP
Some commands change the value of dot, while others
do not.  The print command sets dot to the number of the
last line printed; by our last command, we would have
"." = "$" = 6.
.PP
Dot is most useful when used in combinations like this one:
.DS
.cc #
.+1     (or equivalently, .+1p)
#cc .
.DE
This means "print the next line" and gives us a
handy way to step slowly through a buffer.
We can also say
.DS
.cc #
.-1     (or .-1p)
#cc .
.DE
which means "print the line
.bd 1
before
the current
line." This enables us to go backwards if we
wish.  Another useful one is something like
.DS
.cc #
.-3,.-1p
#cc .
.DE
which prints the previous three lines.
.PP
Don't forget that all of these change the value
of dot.  You can find out what dot is at
any time by typing
.DS
.cc +
.=
+cc .
.DE
.ul
ed
will respond by printing the value of dot.
.PP
Let's summarize some things about the "p"
command and dot.  Essentially "p" can be preceded by
0, 1, or 2 line numbers.  If there is no line
number given, it prints the "current line", the line
that dot refers to.  If there is one line number
given (with or without the letter "p"), it prints
that line (and dot is set there); and if there are two
line numbers, it prints all the lines in that range
(and sets dot to the last line printed.) If two line
numbers are specified the first can't be bigger than the
second (see Exercise 3.)
.PP
Typing a single newline will cause printing of the
next line - it's equivalent to ".+1p".  Try it.
.H2
DELETING LINES:  the "d" command
.PP
Suppose we want to get rid of the three extra
lines in the buffer.  This is done by the
.bd 1
delete
command
.DS
d
.DE
Except that "d" deletes lines instead of printing them,
its action is similar to that of "p".  The
lines to be deleted are specified for "d" exactly as
they are for "p":
.DS
start,end d
.DE
Thus the command
.DS
4,$d
.DE
deletes lines 4 through the end.  There are now
three lines left, as we can check by using
.DS
1,$p
.DE
And notice that "$" now is line 3!  Dot is set to the
next line after the last line deleted, unless the
last line deleted is the last line in the buffer.
In that case, dot is set to "$".
.H2
EXERCISE 4:
.PP
Experiment with "a", "e", "r", "w", "p", and "d" until
you are sure that you know what they do, and until you understand
how dot, "$", and line numbers are used.
.PP
If you are adventurous, try using line numbers
with "a", "r", and "w" as well.  You will find that
"a" will append lines
.bd 1
after
the line number
that you specify (rather than after dot); that "r" reads
a file in
.bd 1
after
the line number you specify
(not necessarily at the end of the buffer); and that "w"
will write out exactly the lines you specify, not
necessarily the whole buffer.  These variations are
sometimes handy.  For instance you can insert a file
at the beginning of a buffer by saying
.DS
0r filename
.DE
and you can enter lines at the beginning of the
buffer by saying
.DS
.cc #
0a
...text...
.
#cc .
.DE
Notice that ".w" is
.bd 1
very
different from
.DS
.cc #
.
w
#cc .
.H2
MODIFYING TEXT:  the Substitute command "s"
.PP
We are now ready to try one of the most important
of all commands - the substitute command
.DS
s
.DE
This is the command that is used to change
individual words or letters within a line or group of
lines.  It is what we use, for example, for correcting
spelling mistakes and typing errors.
.PP
Suppose that by a typing error, line 1 says
.DS
Now is th time
.DE
- the "e" has been left off "the".  We can use "s"
to fix this up as follows:
.DS
1s/th/the/
.DE
This says:  "in line 1, substitute for the characters
'th' the characters 'the'.  To verify that it works
.ul
(ed
will not print the result automatically)
we say
.DS
p
.DE
and get
.DS
Now is the time
.DE
which is what we wanted.  Notice that dot must have
been set to the line where the substitution took place,
since the "p" command printed that line.  Dot is always set
this way with the "s" command.
.PP
The general way to use the substitute command is
.DS
start,end s/change this/to this/
.DE
Whatever string of characters is between
the first pair of slashes is replaced by whatever
is between the second pair, in
.bd 1
all
the lines between
starting line and ending line.  Only the first occurrence on each line
is changed, however.  If you want to change
.bd 1
every
occurrence,
see Exercise 5.  The rules for
line numbers are the same as those for "p", except that dot
is set to the last line changed. (But there is a trap for the
unwary:  if no substitution took place, dot is
.bd 1
not
changed.  This causes an error "?" as a warning.)
.PP
