Thus we can say
.DS
1,$s/speling/spelling/
.DE
and correct the first spelling mistake on each line in the text.
(This is useful for people who are consistent misspellers!)
.PP
If no line numbers are given, the "s" command assumes we
mean "make the substitution on line dot", so it changes things
only on the current line.  This leads to the very common sequence
.DS
s/something/something else/p
.DE
which makes some correction on the current line, and
then prints it, to make sure it worked out right.
If it didn't, we can try again.  (Notice that we put
a print command on the same line as the substitute.  With
few exceptions, "p" can follow any command; no other multi-command
lines are legal.)
.PP
It's also legal to say
.DS
s/something//
.DE
which means "change 'something' to
.bd 1
nothing,"
i.e., remove it.  This
is useful for deleting extra words in a line or
removing extra letters from words.  For instance,
if we had
.DS
Nowxx is the time
.DE
we can say
.DS
s/xx//p
.DE
to get
.DS
Now is the time
.DE
Notice that "//" here means "no characters", not
a blank.  There
.bd 1
is
a difference!  (See below
for another meaning of "//".)
.H2
EXERCISE 5:
.PP
Experiment with the substitute command.  See what
happens if you substitute for some word on a line
with several occurrences of that word.  For
example, do this:
.DS
.cc #
a
the other side of the coin
.
s/the/on the/p
#cc .
.DE
You will get
.DS
on the other side of the coin
.DE
A substitute command changes only the first
occurrence of the first string.  You can change all
occurrences on the line by adding a "g" (for "global") to
the "s" command, like this:
.DS
s/.../.../gp
.DE
Try other characters instead of slashes to delimit the two
sets of characters in the "s" command - anything should
work except blanks or tabs.
.PP
(You will get funny results using any of the characters
.DS
%  ?  $  [  *  @
.DE
these will be explained in
the section on "Special Characters".)
.H2
CONTEXT SEARCHING - "/.../"
.PP
With the substitute command mastered, we can move on
to another highly important idea of
.ul
ed
- context searching.
.PP
Suppose we have our original three line text in the buffer:
.DS
Now is the time
for all good men
to come to the aid of their party.
.DE
Suppose we want to find the line that contains "their"
so we can change it to "the". Now with only three lines in the buffer,
it's pretty easy to keep track of what line the word "their"
is on.  But if the buffer contained several hundred lines, and
we'd been making changes, deleting and rearranging
lines, and so on, we would no longer really know what
this line number would be.  Context searching is simply a method
of specifying the desired line, regardless of what its number is,
by specifying some context on it.
.PP
The way we say "search for a line that contains this
particular string of characters" is to type
.DS
/string of characters we want to find/
.DE
For example, the
.ul
ed
line
.DS
/their/
.DE
is a context search which is sufficient to find the
desired line - it will locate the next occurrence of the
characters between slashes ("their").  It also sets dot
to that line and prints the line for verification:
.DS
to come to the aid of their party.
.DE
"Next occurrence" means that
.ul
ed
starts looking for the
string at line ".+1", searches to the end of the buffer,
then continues at line 1 and searches to line dot.  (That is,
the search "wraps around" from "$" to 1.)  It scans all the
lines in the buffer until it either finds the desired line or
gets back to dot again.  If the given string of characters
can't be found in any line,
.ul
ed
types the error message
.DS
?
.DE
Otherwise it prints the line it found.
.PP
We can do both the search for the desired line
.bd 1
and
a substitution all at once, like this:
.DS
/their/s/their/the/p
.DE
which will yield
.DS
to come to the aid of the party.
.DE
There were three parts to that last command:  context search
for the desired line, make the substitution, print the line.
.PP
The expression "/their/" is a context search expression.
In their simplest form, all context search expressions are like this -
a string of characters surrounded by slashes.  Context searches are
interchangeable with line numbers, so they can be used by
themselves to find and print a desired line, or as line
numbers for some other command, like "s".  We used them both
ways in the examples above.
.PP
Suppose the buffer contains the three familiar lines
.DS
Now is the time
for all good men
to come to the aid of their party.
.DE
Then the
.ul
ed
line numbers
.DS
/Now/+1
/good/
/party/-1
.DE
are all context search expressions, and they all refer to the
same line (line 2).  To make a change in line 2, we could say
.DS
/Now/+1s/good/bad/
.DE
or
/good/s/good/bad/
.DE
or
.DS
/party/-1s/good/bad/
.DE
The choice is dictated only by convenience.  We could print
all three lines by, for instance
.DS
/Now/,/party/p
.DE
or
.DS
/Now/,/Now/+2p
.DE
or by any number of similar combinations.  The first one
of these might be better if we don't know how many lines
are involved.  (Of course, if there were only three lines
in the buffer, we could use
.DS
1,$p
.DE
but not if there were several hundred.)
.PP
The basic rule is:  a context search expression is
.bd 1
the
same as a line number, so it can be used wherever a
line number is needed.
.H2
EXERCISE 6:
.PP
Experiment with context searching.  Try a body of text
with several occurrences of the same string of
characters, and scan through it using the same context search.
,PP
Try using context searches as line numbers for the
substitute, print and delete commands.  (They can also
be used with "r", "w", and "a".)
.PP
Try context searching using "\text\" instead of "/text/".
This scans lines in the buffer in reverse order rather than normal.
This is sometimes useful if you go too far while looking for
some string of characters - it's an easy way to back up.
.PP
(You will get funny results with any of the characters
.DS
%  ?  $  [  *  @
.DE
these will be explained in
the section on "Special Characters".)
.PP
.ul
ed
provides a shorthand for repeating a context search
for the same string.  For example, the
.ul
ed
line number
.DS
/string/
.DE
will find the next occurrence of "string".  It often
happens that this is not the desired line, so the search
must be repeated.  This can be done by typing merely
.DS
//
.DE
This shorthand stands for "the most recently used context
search expression."  It can also be used as the first string
of the substitute command, as in
.DS
/string1/s//string2/
.DE
which will find the next occurrence of "string1" and
replace it by "string2".  This can save a lot of typing.
Similarly
.DS
\\
.DE
means "scan backwards for the same expression."
.H2
CHANGE and INSERT - "c" and "i"
.PP
This section discusses the
.bd 1
change
command
.DS
c
.DE
which is used to change or replace a group of one or more
lines, and the
.bd 1
insert
command
.DS
i
.DE
which is used for inserting a group of one or more lines.
.PP
"Change", written as
.DS
c
.DE
is used to replace a number of lines with different lines,
which are typed in at the terminal.  For example, to
change lines ".+1" through "$" to something else, type
.DS
.cc #
.+1,$c
...type the lines of text you want here...
.
#cc .
.DE
The lines you type between the "c" command and the "."
will take the place of the original lines between
start line and end line.  This is most useful in
replacing a line or several lines which have errors in them.
.PP
If only one line is specified in the "c" command, then
just that line is replaced.  (You can type in as many
replacement lines as you like.)  Notice the use of "." to end
the input - this works just like the "." in the append
command and must appear by itself on a new line.  If no line number
is given, line dot is replaced.  The value of dot is set to
the last line you typed in.
.PP
"Insert" is similar to append - for instance
.DS
.cc #
/string/i
...type the lines to be inserted here...
.
#cc .
.DE
will insert the given text
.bd 1
before
the next line that
contains "string".  The text between "i" and "." is
.bd 1
inserted
before the specified line.  If no line
number is specified dot is used.  Dot is set to the last line inserted.
.H2
EXERCISE 7:
.PP
"Change" is rather like a combination of delete followed by
insert.  Experiment to verify that
.DS
.cc #
start, end d
i
...text...
.
#cc .
.DE
is almost the same as
.DS
.cc #
start, end c
...text...
.
#cc .
.DE
These are not
.bd 1
precisely
the same if line "$"
gets deleted.  Check this out.  What is dot?
.PP
Experiment with "a" and "i", to see that they are
similar, but not the same.
.ne 13
You will observe that
.DS
.cc #
line-number a
...text..
.
#cc .
.DE
appends
.bd 1
after
the given line, while
.DS
.cc #
line-number i
...text...
.
#cc .
.DE
inserts
.bd 1
before
it.  Observe that if no line number is
given, "i" inserts before line dot, while "a"
appends after line dot.
.H2
BROWSING:  the "b" command
.PP
Many times you want to look at several lines
of a large file
while you're using a video terminal.
If you said
.DS
1,$p
.DE
the whole buffer would flash on the screen, usually
too fast to read.  A better way is the browse
command "b".  It prints just enough lines (23)
to fill the CRT screen.  Browse has three major forms which control
what lines are displayed.  "b" or "b+" prints the current
line and the screen after it.  "b." prints the screen
centered on the current line and including it.
"b-" prints the screenful before the current line.
.H2
MOVING TEXT AROUND:  the "m" command
.PP
The move command "m" is used for cutting and pasting - it
lets you move a group of lines from one place to another
in the buffer.  Suppose we want to put the first three lines
of the buffer at the end instead.  We could do it by saying:
.DS
1,3w temp
$r temp
1,3d
.DE
(Do you see why?) but we can do it a lot easier with the "m"
command:
.DS
1,3m$
.DE
The general case is
.DS
start-line, end-line m after-this-line
.DE
Notice that there is a third line to be specified - the
place where the moved stuff gets put.  Of course the lines
to be moved can be specified by context searches; if we had
.DS
.cc #
First paragraph
...
end of first paragraph.
Second paragraph
...
end of second paragraph.
#cc .
.DE
we could reverse the two paragraphs like this:
.DS
/Second/,/second/m/First/-1
.DE
Notice the "-1" - the moved text goes
.bd 1
after
the
line mentioned.  Dot gets set to the last line moved.
.H2
THE GLOBAL COMMAND "g"
.PP
The
.bd 1
global
command "g" is used to execute an
.ul
ed
command on all those lines in the buffer that match some specified
string.  For example
.DS
g/peling/p
.DE
prints all lines that contain "peling".  More usefully,
.DS
g/peling/s//pelling/gp
.DE
makes the substitution everywhere on the line, then prints
each corrected line.  Compare this to
.DS
1,$s/peling/pelling/gp
.DE
which only prints the last line substituted.  Another subtle
difference is that the "g" command does not give a "?"
if "peling" is not found whereas the "s" command will.
.H2
SPECIAL CHARACTERS
.PP
You may have noticed that things just don't work right
when you used some characters like "?", "*", "$", and others
in context searches and the substitute command.  The reason is
rather complex, although  the cure is simple.  Basically,
.ul
ed
treats these characters as special, with special meanings.
For instance,
.bd 1
in
a context search or the first
string of the substitute command only,
.DS
/x?y/
.DE
means "a line with an x,
.bd 1
any
character, and a y,"
.bd 1
not
just
"a line with an x, a question mark, and a y." 
A complete list of the special characters that can
cause trouble is the following:
.DS
%   .   $   [   *   @   #   !
.DE
.bd 1
Warning:
The character @ is special to
.ul
ed.
For safety's sake, avoid it where possible.  If you have
to use one of the special characters in a
substitute command, you can turn off its magic meaning
temporarily by preceding it with the "at" sign.  Thus
.DS
s/@@@?@*/at quest star/
.DE
will change "@?*" into "at quest star".
.PP
Here is a hurried synopsis of the other special characters.
First, the percent "%" signifies the beginning
of a line.  Thus
.DS
/%string/
.DE
finds "string" only if it is at the beginning of a line:
it will find
.DS
string
.DE
.ne 3
but not
.DS
the string...
.DE
The dollar-sign "$" is just the opposite of the
percent sign; it means the end of a line:
.DS
/string$/
.DE
will only find an occurrence of "string" that is at
the end of some line.  This implies, of course,
that
.DS
/%string$/
.DE
will find only a line that contains just "string", and
.DS
/%?$/
.DE
finds a line containing exactly one character.
.PP
The character "?", as we mentioned above, matches anything;
.DS
/x?y/
.DE
matches any of
.DS
xay
x1y
x+y
x-y
x y
x.y
.DE
This is useful in conjunction with "*", which is a
repetition character; "a*" is shorthand for "any
number of a's", so "?*" matches any number of
anythings.  This is used like this:
.DS
s/?*/stuff/
.DE
which changes an entire line, or
.DS
s/?*,//
.DE
which deletes all characters in the line up to and
including the last comma.  (Since "?*" finds the longest
possible match, this goes up to the last comma.)
.PP
"[" is used with "]" to form "character classes";
for example,
.DS
/[1234567890]/
.DE
matches any single digit - any one of the characters
inside the braces will cause a match.
.PP
Finally, the "&" is another shorthand character - it is
used only on the right-hand part of a substitute command where
it means "whatever was matched on the left-hand side".  It is used
to save typing.  Suppose the current line contained
.DS
Now is the time
.DE
and we wanted to put parentheses around it.  We could
just retype the line, but this is tedious.  Or we could say
.DS
s/%/(/
s/$/)/
.DE
using our knowledge of "%" and "$".  But the easiest
way uses the "&":
.DS
s/?*/(&)/
.DE
This says "match the whole line, and replace it by itself
surrounded by parens."  The "&" can be used several times
in a line; consider using
.DS
s/?*/&. &!!/
.DE
to produce
.DS
Now is the time.  Now is the time!!
.DE
We don't have to match the whole line, of course:  if the
buffer contains
.DS
the end of the world
.DE
we could type
.DS
/world/s//& is at hand/
.DE
to produce
.DS
the end of the world is at hand
.DE
Observe this expression carefully, for it illustrates
how to take advantage of
.ul
ed
to save typing.  The
string "/world/" found the desired line; the
shorthand "//" found the same word in the line;
and the "&" saved us from typing it again.
.PP
The "&" is a special character only within the
replacement text of a substitute command, and has no
special meaning elsewhere.  We can turn off the special
meaning of "&" by preceding it with a "@":
.DS
s/ampersand/@&/
.DE
will convert the word "ampersand" into the literal
symbol "&" in the current line.
.H2
ACKNOWLEDGEMENT
.PP
The majority of this document has been taken, with
the author's permission, from
"A Tutorial Introduction to
the UNIX Text Editor" by B. W. Kernighan.
It has been changed
only to reflect
the differences between this editor and the UNIX version.
.H2
SUMMARY OF COMMANDS AND LINE NUMBERS
.PP
The general form of
.ul
ed
commands is the command name,
perhaps preceded by one or two line numbers, and, in the
case of
.bd 1
e, r
and
.bd 1
w,
followed by a file name.
Only one command is allowed per line, but a
.bd 1
p
command may
follow any other command (except for
.bd 1
e, r, w
and
.bd 1
q).
.IP
.bd 1
a
(append) Add lines to the buffer (at line dot,
unless a different line is specified).  Appending continues
until "." is typed on a new line.  Dot is set
to the last line appended.
.IP
.bd 1
b
(browse) Display the next 23 lines of text, beginning at the current
line.  The current line will be centered if you use "b.".
Using "b-" will cause the previous 23 lines to be printed,
while "b+" will do the same as "b".
.IP
.bd 1
c
(change) Change the specified lines to the new
text which follows.  The new lines are terminated by a ".".
If no lines are specified, replace line dot.  Dot is set to the last line
changed.
.IP
.bd 1
d
(delete) Delete the lines specified. If none are
specified, delete line dot.  Dot is set to the first undeleted
line, unless "$" is deleted, in which case dot is set to "$".
.IP
.bd 1
e
(edit) Edit new file.  Any previous contents of the buffer
are thrown away, so issue a
.bd 1
w
beforehand if you
want to save them.
.IP
.bd 1
f
(file) Print remembered filename.  If a name follows
.bd 1
f
the remembered name will be set to it.
.IP
.bd 1
g
(global) g/---/command will execute the command on
those lines that contain "---", which can be
any context search expression.
.IP
.bd 1
i
(insert) Insert lines before specified line (or dot)
until a "." is typed on a new line.  Dot is set to the last line inserted.
.IP
.bd 1
m
(move) Move lines specified to after the line named after
.bd 1
m.
Dot is set to the last line moved.
.IP
.bd 1
p
(print) Print specified lines.  If none specified,
print line dot.  A single line number is equivalent to "line-number p".
A single newline prints ".+1", the next line.
.IP
.bd 1
q
(quit) Exit from ed.  Wipes out all text in the buffer!!
.IP
.bd 1
r
(read) Read a file into the buffer (at end unless specified
elsewhere.)  Dot is set to last line read.
.IP
.bd 1
s
(substitute) s/string1/string2/ will substitute the
characters of 'string2' for 'string1' in specified lines.
If no line is specified, make substitution in line dot.
Dot is set to the last line in which a substitution took place,
which means that if no substitution took place,
dot is not changed.
.bd 1
s
changes only the first occurrence
of string1 on a line;
to change all of them, type a "g" after the final slash.
.IP
.bd 1
w
(write) Write out buffer onto a file.  Dot is not changed.
.IP
.bd 1
.cc #
.=
#cc .
(dot value) Print value of dot.  ("=" by itself
prints the value of "$".)
.IP
.bd 1
/---/
Context search.  Search for the next line that
contains this string of characters.  Print it.  Dot is set to
line where the string was found.  Search starts at ".+1", wraps around from
"$" to 1, and continues to dot, if necessary.
.IP
.bd 1
\---\
Context search in reverse direction.  Start the search at
".-1", scan to 1, wrap around to "$".
